; This is a wireframe version of a textual editor for Eve. Ultimately,
; this is unlikely to be how people interact with the system, but it
; gives us an opportunity to work with the language before the real
; workflow has fully come together and test the language in fun and
; interesting ways.

; Eve is based on datalog, but you can think of it more as a non-crappy
; SQL. As such, the operations you have available to you look and feel
; like relational algebra. As a matter of fact, everything in Eve is
; just a view over some inputs. Let's see how we define a view:

* user
  ~ name age
  + "Chris" 27

; The * denotes a new view. The symbol that follows it is its name.
; You'll also notice that there's a table card on the right. Based on
; that card, you can see that the first is defining the headers of
; the view, the second adds a single row with the name "Chris" and the
; age 27. Let's see how we use that information in another view to
; calculate when I was born by uncommenting the code below:

;* yearBorn
;  | user age
;  born = 2014 - @age

; Here we've defined "yearBorn", which selects the age from the "user"
; view and then calculates a new column called "born". Everything after
; an equals sign is a javascript function right, so in order to
; denote the we want the value of the age column, not some random
; bit of js, we precede the symbol with an @. This allows you to do
; the equivalent of formulas in Excel.

; Also like Excel, everything in Eve is live - this is one of the
; benefits we get from everything being a view. Try adding a new name
; and age to the user view and see what happens. You'll see that all
; the views update and now have multiple rows. But right now, our
; information is in two different tables. Let's see how we can join
; the yearBorn and user view together:

;* userBorn
;  | user name age
;  | yearBorn age born

; Joins are implicit in Eve, which means columns referenced with the same
; symbol are joined automatically. To have greater control over this, you
; can alias fields by doing column:alias like so:

;* userBornAlias
;  | user name age:a
;  | yearBorn age:a born:birthYear

; You can also filter your views by a value using column=value:

;* peopleAged27
;  | user name age=27

; Only being able to filter by constants would be fairly limiting though,
; so you can also filter via a javascript function that returns true or
; false using the ? operator:

;* peopleOlderThan 25
;  | user name age
;  ? @age > 25

; So that lets us do the standard relational operations, but we're missing
; a way to calculate over a set of rows (e.g. to sum something or take
; the average). For example, let's see how we would calculate the average
; age of our users:

;* averageAge
;  > user | age = avg(@user.age)

; The > denotes that we're doing an aggregation, taking lots of rows and
; turning them into a single value. We name that value "age" in this case
; and set it equal to a function that takes the average of the age column
; in the user table. Note that if we had used @age instead of @user.age
; it would mean the age field in the current view as opposed to the
; age field in the table we're aggregating over.

; One other thing we added syntax for is UI since it's pretty common in
; applications. We represent HTML as nested lists denoted by
; enclosing brackets like so:

;* drawUsers
;  | user name age
;  ["p" {"id" name} name " is " age " years old."]

; You'll note at the top of our stack of cards that a UI card has now
; appeared and that there are lines for each user in the user table.
; In order to get a line per user, we needed to make each paragraph
; unique by giving it an id as Eve has set semantics. The second element
; of a UI list can be a map of attributes. The first is the type of HTML
; tag and everything else is interpreted as a child. You can nest these
; lists to your heart's content.

; And that's more or less it. The entire language is just stringing these
; views together in interesting ways. Checkout the various examples to get
; a feel for how these things start to come together and see some more
; advanced notions like views that have multiple contributors (which
; allows you to do recursion).
