{:data {program

		{:data {}

 :pipes [{:name root
		  :pipe [(get-data)
				 (clean _PREV_)
				 (to-graph _PREV_)]}

		 {:name get-data
		  :pipe [[{"time" 59 "date" "8/26/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 59 "date" "8/26/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 59 "date" "8/28/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 114 "date" "8/29/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 90 "date" "8/30/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 59 "date" "8/26/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 59 "date" "8/26/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 59 "date" "8/26/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  {"time" 59 "date" "8/26/2013"} {"time" 23 "date" "8/26/2013"} {"time" 224 "date" "8/27/2013"} {"time" 70 "date" "8/27/2013"}
				  ]
				 ]}

		 {:name clean
		  :scope [things]
		  :pipe [(filter-match [gt10 (fn [x] (> x 10))]
							   {"time" (_ :guard gt10)}
							   things)
				 (group-by "date" _PREV_)
				 (vals _PREV_)
				 (each _PREV_ do-math)
				 ]}

		 {:name do-math
		  :scope [thing]
		  :pipe [(core/extract thing "time")
				 (core/!math ["/" ["sum" _PREV_] ["count" _PREV_]])
				 ]}

		 {:name to-graph
		  :scope [data]
		  :pipe [(core/!chart {"type" "line"
							   "values" data
							   "bezierCurve" true
							   "x" ["monday" "tuesday" "wednesday" "thursday" "friday"]})]}

		 ]

 :main root}


        state {"pipe" root
			   "step" 0
			   "prev" []
			   "dirty" true}}
 :pipes [

		 {:name find-pipe
		  :scope [name]
		  :pipe [(-> (filter-match [cur name]
								   {:name cur}
								   (get-in program [:pipes]))
					 first)]}

         {:name show
          :pipe [(core/ctx! :app)
				 (when (state "dirty")
				   (println "re running")
				   (core/!runner program)
				   (commute (assoc state "dirty" false)))
				 (let [cur (find-pipe (state "pipe"))]
				   [:div#aurora
					;(->data)
					(->pipeline cur)
					(->workspace cur)
					])
                 (core/root-inject _PREV_)
				 ]}


         {:name ->data
          :pipe [[:ul.data
                  (each-meta (program :data) ->data-rep)]]}

         {:name ->data-rep
          :scope [[k v]]
          :pipe [[:li (pr-str v)]]}

		 {:name ->match-pair
		  :scope [pipe [match action]]
		  :pipe [[:div.entry (pr-str match) (step-rep pipe action)]]}

		 {:name ->match-ui
		  :scope [match]
		  :pipe [[:div.match (pr-str (second match))
				  (each-meta (partition 2 (drop 2 match)) (partial ->match-pair pipe))]]}

		 {:name ->filter-match-ui
		  :scope [match]
		  :pipe [[:div.match "filter-match"]]}

		 {:name set-pipe
		  :scope [func]
		  :pipe [(update-in state ["prev"] conj (state "pipe"))
				 (assoc _PREV_ "pipe" func)
				 (assoc _PREV_ "step" 0)
				 (commute _PREV_)]}

		 {:name filter-in-scope
		  :scope [pipe args]
		  :pipe [
				 (set (:scope pipe))
				 (remove _PREV_ args)]}

		 {:name get-in-scope
		  :scope [pipe var depth]
		  :pipe [(if (= var (symbol "_PREV_"))
				   (js/aurora.transformers.editor.->step (:name pipe) (dec (:cur-step pipe)))
				   (-> (js/aurora.transformers.editor.->scope (:name pipe))
					   (get var)
					   (get-in depth))

						)
				 ]}

		 {:name ->invocation
		  :scope [func args pipe]
		  :pipe [(let [pipe? (find-pipe func)
					   data? (get-in program [:data func])
					   in-scope? ((set (:scope pipe)) func)
					   attrs (if pipe?
							   {"click" (partial set-pipe func)
								"class" "func pipeline"}
							   {})
					   prev (symbol "_PREV_")]
				   (match [pipe? data? in-scope? func]
						  [(_ :guard boolean) _ _ _] (if-let [desc (op-lookup func args pipe)]
													 [:div.func attrs desc]
													 [:div.func attrs "(" [:div (-> func str)] (each-meta (filter-in-scope pipe args) (partial step-rep pipe)) ")"])
						  [_ _ (_ :guard boolean) _] [:div.data  (pr-str (get-in-scope pipe func args))]
						  [_ _ _ 'partial] (->invocation (first args) (rest args) pipe)
						  [_ _ _ prev] [:div.prev.data (pr-str (js/aurora.transformers.editor.->step (:name pipe) (dec (:cur-step pipe))))]
						  :else (if-let [desc (op-lookup func args pipe)]
								  [:div.func attrs desc]
								  [:div.func attrs "(" [:div (-> func str)] (each-meta args (partial step-rep pipe)) ")"]))

				 )]}

		 {:name ensure-meta
		  :scope [thing path]
		  :pipe [(if (satisfies? IMeta thing)
				   (with-meta thing {:path path})
				   (js/aurora.engine.as-meta thing path))]}

		 {:name ->map-entry
		  :scope [pipe path [k v] class]
		  :pipe [[:li {"class" (str "entry " class)}
				  (step-rep pipe (ensure-meta k (cljs.core/conj path k :aurora.core/key)))
				  (step-rep pipe (ensure-meta v (cljs.core/conj path k)))]]
		  }

		 {:name op-lookup
		  :scope [op args pipe ]
		  :pipe [(match [op]
						['assoc] [:div.map "{" (for [[k v] (get-in-scope pipe (first args))]
												 (if (= k (second args))
												   (->map-entry pipe [] [k (nth args 2)] "assoc")
												   (->map-entry pipe [] [k v] ))) "}"]
						;(list "In " (->invocation (first args) nil pipe) " set " (str (second args) " to " (nth args 2)))

						['commute] (str "Replace")
						['core/inject] (str "To html")
						['conj] (let [cur (get-in-scope pipe (first args))
									  cnt (count cur)
									  cur (if (> cnt 2)
											(apply vector "..." (subvec cur (- cnt 3) cnt))
											cur)]

								  [:div.vector "[" (each cur pr-str) [:div.assoc (step-rep pipe (second args))] "]"]
								  )
						;(list "Append " (pr-str (second args)) " to " (->invocation (first args) nil pipe))
						:else nil)]}

		 {:name ->math-rep
		  :scope [form]
		  :pipe [(match [(core/type form) form]
						[:vector (["count" & r] :seq)] [:span.math-op.math-count "n"]
						[:vector (["sum" & r] :seq)] [:span.math-op [:span.math-sigma "Î£"] "x" [:sub "i"] ]
						[:vector _] [:div.math-expression (each-meta (interpose (first form) (rest form)) ->math-rep)]
						[:string "/"] [:div.math-divider]
						[:string _] [:span.math-op form]
						:else [:span.prim (str form)])]}

		 {:name set-step
		  :scope [i]
		  :pipe [(assoc state "step" i)
				 (commute _PREV_)]}

		 {:name ->steps-ui
		  :scope [pipe]
		  :pipe []}

		 {:name ->math
		  :scope [math-call]
		  :pipe [(rest math-call)
				 [:div.math (each _PREV_ ->math-rep)]
				 ]}

		 {:name program-commute
		  :scope [thing]
		  :pipe [(commute thing)
				 (assoc state "dirty" true)
				 (commute _PREV_)]}

		 {:name chart-make-pie
		  :scope [chart]
		  :pipe [
				 (match [(chart "type")]
						["pie"] "line"
						["line"] "pie")
				 (assoc chart "type" _PREV_)
				 (program-commute _PREV_)]
		  }

		 {:name ->chart-ed
		  :scope [chart-call]
		  :pipe [(println (meta chart-call))
				 [:div.chart-ed {"click" (partial chart-make-pie (second chart-call))}
				  "make pie"
				  ]]}

		 {:name modify-primitive
		  :scope [cur]
		  :pipe [(println "time to modify: " (meta cur) (assoc state "modifying" (-> cur meta :path)))
				 (when-let [path (-> cur meta :path)]
				 (commute (assoc state "modifying" path)))]}

		 {:name set-primitive
		  :scope [cur e]
		  :pipe [(println "set primitive!" (-> prim meta :path))
				 (cond
				  (string? @cur) (e "value")
				  (core/is-float? @cur) (js/parseFloat (e "value"))
				  (number? @cur) (js/parseInt (e "value"))
				  :else (e "value"))
				 (core/commute-path (-> cur meta :path) _PREV_)
				 (println "commuting state" (meta state))
				 (assoc state "dirty" true)
				 (commute (assoc _PREV_ "modifying" nil))]}

		 {:name primitive-or-editor
		  :scope [prim val class]
		  :pipe [(let [path (-> prim meta :path)]
				   (if (and path
							(= path (state "modifying")))
					 [:input.prim-editor {"enter" (partial set-primitive prim) :value @prim :focused true}]
					 [:div {"class" class "click" (partial modify-primitive prim)} val])
				   )]}

		 {:name step-rep
		  :scope [pipe substep]
		  :pipe [(let [prev (symbol "_PREV_")
					   not-sym (complement symbol)
					   cur (if (satisfies? IDeref substep)
							 @substep
							 substep)]
				 (match [(core/type substep) substep]
                        [:vector _] [:div.vector (each-meta substep (partial step-rep pipe))]
                        [:list (['match & r] :seq)] (->match-ui substep pipe)
						[:list (['filter-match & r] :seq)] (->filter-match-ui substep)
						[:list (['core/!math & r] :seq)] (->math substep)
						[:list (['core/!chart & r] :seq)] (->chart-ed substep)
                        [:list ([func & r] :seq)] (if (symbol? func)
													(->invocation func r pipe)
													(each-meta substep (partial step-rep pipe)))
						[:seq _] (each-meta substep (partial step-rep pipe))
						[:map _] [:ul.map "{" (each substep (partial ->map-entry pipe (-> substep meta :path))) "}"]
						[:number _] (primitive-or-editor substep (str cur) "number")
						[:symbol _] (->invocation substep nil pipe)
                        [:string _] (primitive-or-editor substep cur "string")
                        [:keyword _] [:div.string (str cur)]
						[:fn _] [:div.fn "fn"]
						[:html _] [:div.html "Html!"]
                        :else (pr-str cur)))]}

         {:name ->pipe-step
          :scope [pipe substep]
          :pipe [[:li {
					   "class" (let [i (core/last-path substep)]
								 (match [(state "step")]
										[i] "active"
										:else ""))}
				  (step-rep (assoc pipe :cur-step (core/last-path substep)) substep)
				  (when-let [cap (js/aurora.transformers.editor.->step (:name pipe) (core/last-path substep))]
					[:div.result (step-rep (assoc pipe :cur-step (core/last-path substep)) cap)])
				  ]]}

		 {:name ->backup
		  :scope [cur]
		  :pipe [(assoc state "prev" (vec (take (core/last-path cur) (state "prev"))))
				 (assoc _PREV_ "pipe" cur)
				 (commute _PREV_)]}

		 {:name ->prev-step
		  :scope [p]
		  :pipe [["li" {"click" (partial ->backup p)}]]}

         {:name ->pipeline
          :scope [pipe]
          :pipe [[:ul.breadcrumb
				  (each-meta (state "prev") ->prev-step)
                  ]]}

		 {:name ->workspace
		  :scope [pipe]
		  :pipe [[:ul.workspace
				  (when-let [cap (js/aurora.transformers.editor.->scope (:name pipe))]
					[:li.scope (for [[k v] cap]
								 (step-rep pipe (if (satisfies? IMeta v)
												  (with-meta v {:path ['program :data k]})
												  (js/aurora.engine.as-meta v ['program :data k]))))])
				  (each-meta (pipe :pipe) (partial ->pipe-step pipe))]]}

         ]
 :main show}

