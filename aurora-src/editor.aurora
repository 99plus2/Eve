{:data {program

{:data {todos [{"todo" "Get milk" "done?" false}]
        state {"state" "all"}}

 :pipes [

         {:name ->todo
          :scope [todos current-todo]
          :pipe [(match [current-todo]
                        [{"editing?" true}] ["li.editing"
                                             ["input" {"enter" (partial ->edit current-todo) "value" (current-todo "todo")}]]
                        :else ["li" {"class" (->done-class current-todo)}
                               ["input" {"checked" (current-todo "done?") "type" "checkbox" "click" (partial ->toggle-done current-todo)}]
                               ["label" {"dblclick" (partial ->editing current-todo)} (current-todo "todo")]
                               ["button" {"click" (partial ->rem todos current-todo)} ""]])]}

         {:name ->active-todos
		  :scope [todos state]
          :pipe [(match [(state "state")]
                        ["all"] todos
                        ["active"] (filter-match {"done?" false} todos)
                        ["completed"] (filter-match {"done?" true} todos))]}

         {:name root
		  :scope [todos state]
		  :pipe [["div#todoapp"
				  ["header#header"
				   [:h1 "Todos"]
				   [:input#toggle-all {"type" "checkbox" "click" (partial ->all-completed todos state) "checked" (state "all-toggle")}]
				   ["input#new-todo" {"enter" (partial ->add todos) "placeholder" "What needs to be done?"}]]
				  ["ul#todo-list"
				   (each (->active-todos todos state) (partial ->todo todos))]
				  ["div#footer"
				   ["span#todo-count" (->left todos)]
				   ["ul#filters"
					["li" [:a {"click" (partial ->state state "all") "class" (->state-class state "all")} "All"]]
					["li" [:a {"click" (partial ->state state "active") "class" (->state-class state "active")} "Active"]]
					["li" [:a {"click" (partial ->state state "completed") "class" (->state-class state "completed")} "Completed"]]]
				   (->rem-completed-button todos)]]
				 (core/inject _PREV_)]}

         {:name ->done-class
          :scope [current-todo]
          :pipe [(match [(current-todo "done?")]
                        [true] "completed"
                        :else "")]}

         {:name ->set-done
          :scope [state current-todo]
          :pipe [(assoc current-todo "done?" (state "all-toggle"))]}

         {:name ->all-completed
		  :scope [todos state]
          :pipe [(assoc state "all-toggle" (not (state "all-toggle")))
                 (commute _PREV_)
                 (each todos (partial ->set-done state))
                 (commute _PREV_)]}

         {:name ->add
          :scope [todos e]
          :pipe [{"todo" (e "value")
				  "done?" false}
				 (conj todos _PREV_)
                 (commute _PREV_)]}

         {:name ->editing
          :scope [current-todo]
          :pipe [(assoc current-todo "editing?" true)
				 (commute _PREV_)
				 ]}

         {:name ->edit
          :scope [current-todo e]
          :pipe [(assoc current-todo "todo" (e "value"))
				 (assoc _PREV_ "editing?" false)
                 (commute _PREV_)]}

         {:name ->toggle-done
          :scope [current-todo]
          :pipe [(match [current-todo]
                        [{"done?" true}] false
                        :else true)
                 (assoc current-todo "done?" _PREV_)
                 (commute _PREV_)]}

         {:name ->rem
          :scope [todos current-todo]
          :pipe [(rem current-todo todos)
                 (commute _PREV_)]}

         {:name ->rem-completed
		  :scope [todos]
          :pipe [(filter-match {"done?" false} todos)
                 (commute _PREV_)]}

         {:name ->rem-completed-button
          :scope [todos current-todo]
          :pipe [(count (filter-match {"done?" true} todos))
                 (match [_PREV_]
                        [0] nil
                        [cur] [:button#clear-completed {"click" (partial ->rem-completed todos)} "Clear completed (" cur ")"])]}

         {:name ->left
		  :scope [todos]
          :pipe [(filter-match {"done?" false} todos)
				 (count _PREV_)
                 (match [_PREV_]
                        [1] (str "1 item left")
                        [cur] (str cur " items left" ))]}

         {:name ->state
          :scope [state val]
          :pipe [(assoc state "state" val)
                 (commute _PREV_)]}

         {:name ->state-class
          :scope [state val]
          :pipe [(match [(state "state")]
                        [val] "active"
                        :else "")]}
         ]

 :main root}

        state {"pipe" root
			   "step" 0
			   "prev" []
			   "dirty" true}}
 :pipes [

		 {:name find-pipe
		  :scope [name]
		  :pipe [(-> (filter-match [cur name]
								   {:name cur}
								   (get-in program [:pipes]))
					 first)]}

         {:name show
          :pipe [(when (state "dirty")
				   (core/!runner program)
				   (commute (assoc state "dirty" false)))
				 (let [cur (find-pipe (state "pipe"))]
				   [:div#aurora
					;(->data)
					(->pipeline cur)
					(->workspace cur)
					])
                 (core/inject _PREV_)
				 ]}


         {:name ->data
          :pipe [[:ul.data
                  (each (program :data) ->data-rep)]]}

         {:name ->data-rep
          :scope [[k v]]
          :pipe [[:li (pr-str v)]]}

		 {:name ->match-pair
		  :scope [pipe [match action]]
		  :pipe [[:div.entry (pr-str match) (step-rep pipe action)]]}

		 {:name ->match-ui
		  :scope [match]
		  :pipe [[:div.match (pr-str (second match))
				  (each (partition 2 (drop 2 match)) (partial ->match-pair pipe))]]}

		 {:name ->filter-match-ui
		  :scope [match]
		  :pipe [[:div.match "filter-match"]]}

		 {:name set-pipe
		  :scope [func]
		  :pipe [(update-in state ["prev"] conj (state "pipe"))
				 (assoc _PREV_ "pipe" func)
				 (assoc _PREV_ "step" 0)
				 (commute _PREV_)]}

		 {:name filter-in-scope
		  :scope [pipe args]
		  :pipe [
				 (set (:scope pipe))
				 (remove _PREV_ args)]}

		 {:name get-in-scope
		  :scope [pipe var depth]
		  :pipe [(if (= var (symbol "_PREV_"))
				   (js/aurora.transformers.editor.->step (:name pipe) (dec (:cur-step pipe)))
				   (-> (js/aurora.transformers.editor.->scope (:name pipe))
					   (get var)
					   (get-in depth))

						)
				 ]}

		 {:name ->invocation
		  :scope [func args pipe]
		  :pipe [(let [pipe? (find-pipe func)
					   data? (get-in program [:data func])
					   in-scope? ((set (:scope pipe)) func)
					   attrs (if pipe?
							   {"click" (partial set-pipe func)
								"class" "func pipeline"}
							   {})
					   prev (symbol "_PREV_")]
				   (match [pipe? data? in-scope? func]
						  [(_ :guard boolean) _ _ _] (if-let [desc (op-lookup func args pipe)]
													 [:div.func attrs desc]
													 [:div.func attrs "(" [:div (-> func str)] (each (filter-in-scope pipe args) (partial step-rep pipe)) ")"])
						  [_ _ (_ :guard boolean) _] [:div.data  (pr-str (get-in-scope pipe func args))]
						  [_ _ _ 'partial] (->invocation (first args) (rest args) pipe)
						  [_ _ _ prev] [:div.prev.data (pr-str (js/aurora.transformers.editor.->step (:name pipe) (dec (:cur-step pipe))))]
						  :else (if-let [desc (op-lookup func args pipe)]
								  [:div.func attrs desc]
								  [:div.func attrs "(" [:div (-> func str)] (each args (partial step-rep pipe)) ")"]))

				 )]}

		 {:name ->map-entry
		  :scope [pipe [k v] class]
		  :pipe [[:li {"class" (str "entry " class)} (step-rep pipe k) (step-rep pipe v)]]
		  }

		 {:name op-lookup
		  :scope [op args pipe ]
		  :pipe [(match [op]
						['assoc] [:div.map "{" (for [[k v] (get-in-scope pipe (first args))]
												 (if (= k (second args))
												   (->map-entry pipe [k (nth args 2)] "assoc")
												   (->map-entry pipe [k v] ))) "}"]
						;(list "In " (->invocation (first args) nil pipe) " set " (str (second args) " to " (nth args 2)))

						['commute] (str "Replace")
						['core/inject] (str "To html")
						['conj] (let [cur (get-in-scope pipe (first args))
									  cnt (count cur)
									  cur (if (> cnt 2)
											(apply vector "..." (subvec cur (- cnt 3) cnt))
											cur)]

								  [:div.vector "[" (each cur pr-str) [:div.assoc (step-rep pipe (second args))] "]"]
								  )
						;(list "Append " (pr-str (second args)) " to " (->invocation (first args) nil pipe))
						:else nil)]}

		 {:name ->math-rep
		  :scope [form]
		  :pipe [(match [(core/type form) form]
						[:vector (["count" & r] :seq)] [:span.math-op.math-count "n"]
						[:vector (["sum" & r] :seq)] [:span.math-op [:span.math-sigma "Î£"] "x" [:sub "i"] ]
						[:vector _] [:div.math-expression (each (interpose (first form) (rest form)) ->math-rep)]
						[:string "/"] [:div.math-divider]
						[:string _] [:span.math-op form]
						:else [:span.prim (str form)])]}

		 {:name set-step
		  :scope [i]
		  :pipe [(assoc state "step" i)
				 (commute _PREV_)]}

		 {:name ->steps-ui
		  :scope [pipe]
		  :pipe []}

		 {:name ->math
		  :scope [math-call]
		  :pipe [(rest math-call)
				 [:div.math (each _PREV_ ->math-rep)]
				 ]}

		 {:name step-rep
		  :scope [pipe substep]
		  :pipe [(let [prev (symbol "_PREV_")
					   not-sym (complement symbol)]
				 (match [(core/type substep) substep]
                        [:vector _] [:div.vector (each substep (partial step-rep pipe))]
                        [:list (['match & r] :seq)] (->match-ui substep pipe)
						[:list (['filter-match & r] :seq)] (->filter-match-ui substep)
						[:list (['core/!math & r] :seq)] (->math substep)
                        [:list ([func & r] :seq)] (if (symbol? func)
													(->invocation func r pipe)
													(each substep (partial step-rep pipe)))
						[:seq _] (each substep (partial step-rep pipe))
						[:map _] [:ul.map "{" (each substep (partial ->map-entry pipe)) "}"]
						[:number _] [:div.number (str substep)]
						[:symbol _] (->invocation substep nil pipe)
                        [:string _] [:div.string substep]
                        [:keyword _] [:div.string (str substep)]
						[:fn _] [:div.fn "fn"]
						[:html _] [:div.html "We have html!"]
                        :else (pr-str substep)))]}

         {:name ->pipe-step
          :scope [pipe substep]
          :pipe [[:li {"click" (partial set-step (core/last-path substep))
					   "class" (let [i (core/last-path substep)]
								 (match [(state "step")]
										[i] "active"
										:else ""))}
				  (step-rep (assoc pipe :cur-step (core/last-path substep)) substep)
				  (when-let [cap (js/aurora.transformers.editor.->step (:name pipe) (core/last-path substep))]
					[:div.result (step-rep (assoc pipe :cur-step (core/last-path substep)) cap)])
				  ]]}

		 {:name ->backup
		  :scope [cur]
		  :pipe [(assoc state "prev" (vec (take (core/last-path cur) (state "prev"))))
				 (assoc _PREV_ "pipe" cur)
				 (commute _PREV_)]}

		 {:name ->prev-step
		  :scope [p]
		  :pipe [["li" {"click" (partial ->backup p)}]]}

         {:name ->pipeline
          :scope [pipe]
          :pipe [[:ul.breadcrumb
				  (each (state "prev") ->prev-step)
                  ]]}

		 {:name ->workspace
		  :scope [pipe]
		  :pipe [[:ul.workspace
				  (when-let [cap (js/aurora.transformers.editor.->scope (:name pipe))]
					[:li.scope (pr-str cap)])
				  (each (pipe :pipe) (partial ->pipe-step pipe))]]}

         ]
 :main show}

